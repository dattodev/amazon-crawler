<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
			rel="stylesheet"
		/>
		<link rel="stylesheet" href="/dashboard/dashboard.css" />
		<title>Category Insight Dashboard</title>

		<style>
			:root {
				--heatmap-green: #22c55e;
				--heatmap-red: #ef4444;
				--heatmap-yellow: #facc15;
				--heatmap-orange: #ff9f43;
				--primary-orange: #ff7a00;
				--primary-orange-hover: #e66a00;
				--primary-orange-light: #fff4e6;
				--heatmap-text: #111;
			}

			input,
			select,
			button,
			body {
				font-family: 'Inter', sans-serif;
			}

			.category-insight-dashboard-wrapper {
				width: 100%;
				height: 100vh;
				display: flex;
				background: linear-gradient(180deg, #fafbfc 0%, #f4f6f8 100%);
			}

			/* Sidebar */
			.sidebar {
				width: 280px;
				background: white;
				border-right: 1px solid #e0e0e0;
				display: flex;
				flex-direction: column;
				box-shadow: 2px 0 8px rgba(0, 0, 0, 0.06);
			}

			.sidebar-header {
				padding: 20px;
				border-bottom: 1px solid #f0f0f0;
				background: #fafafa;
			}

			.sidebar-header h3 {
				margin: 0 0 8px 0;
				font-size: 18px;
				font-weight: 600;
				color: var(--primary-orange);
			}

			.sidebar-stats {
				font-size: 12px;
				color: #666;
			}

			.sidebar-actions {
				margin-top: 12px;
			}

			.manage-categories-link {
				display: inline-block;
				padding: 8px 16px;
				background: var(--primary-orange);
				color: white;
				text-decoration: none;
				border-radius: 6px;
				font-size: 13px;
				font-weight: 500;
				transition: all 0.2s ease;
				box-shadow: 0 2px 4px rgba(255, 122, 0, 0.2);
			}

			.manage-categories-link:hover {
				background: var(--primary-orange-hover);
				transform: translateY(-1px);
				box-shadow: 0 4px 8px rgba(255, 122, 0, 0.3);
			}

			.sidebar-content {
				flex: 1;
				overflow-y: auto;
			}

			.category-list {
				padding: 8px;
			}

			/* Search box */
			.category-search {
				margin-bottom: 12px;
			}

			.category-search input {
				width: 100%;
				padding: 8px 12px;
				border: 1px solid #e0e0e0;
				border-radius: 6px;
				font-size: 13px;
				background: #fafafa;
				transition: all 0.2s ease;
			}

			.category-search input:focus {
				outline: none;
				border-color: var(--primary-orange);
				background: white;
				box-shadow: 0 0 0 2px rgba(255, 122, 0, 0.1);
			}

			/* All/Clear controls */
			.category-controls {
				display: flex;
				align-items: center;
				gap: 8px;
				margin-bottom: 12px;
				padding: 8px 0;
				border-bottom: 1px solid #f0f0f0;
			}

			.category-controls .checkbox-wrapper {
				display: flex;
				align-items: center;
				gap: 6px;
				cursor: pointer;
				user-select: none;
			}

			.category-controls .checkbox-wrapper input[type='checkbox'] {
				width: 16px;
				height: 16px;
				accent-color: var(--primary-orange);
				cursor: pointer;
				appearance: none;
				-webkit-appearance: none;
				-moz-appearance: none;
				border: 2px solid #ddd;
				border-radius: 3px;
				background: white;
				position: relative;
			}

			.category-controls
				.checkbox-wrapper
				input[type='checkbox']:checked {
				background: var(--primary-orange);
				border-color: var(--primary-orange);
			}

			.category-controls
				.checkbox-wrapper
				input[type='checkbox']:checked::after {
				content: '✓';
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				color: white;
				font-size: 12px;
				font-weight: bold;
			}

			.category-controls .checkbox-wrapper label {
				font-size: 13px;
				font-weight: 500;
				color: var(--primary-orange);
				cursor: pointer;
				margin: 0;
			}

			.category-controls .clear-btn {
				margin-left: auto;
				padding: 4px 8px;
				background: none;
				border: 1px solid #e0e0e0;
				border-radius: 4px;
				font-size: 12px;
				color: #666;
				cursor: pointer;
				transition: all 0.2s ease;
			}

			.category-controls .clear-btn:hover {
				background: #f5f5f5;
				border-color: var(--primary-orange);
				color: var(--primary-orange);
			}

			/* Category items with checkboxes */
			.category-item {
				padding: 8px 12px;
				margin: 2px 0;
				border-radius: 6px;
				cursor: pointer;
				transition: all 0.2s ease;
				border: 1px solid transparent;
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.category-item:hover {
				background: var(--primary-orange-light);
				border-color: rgba(255, 122, 0, 0.2);
			}

			.category-item.selected {
				background: var(--primary-orange-light);
				border-color: var(--primary-orange);
			}

			.category-item input[type='checkbox'] {
				width: 16px;
				height: 16px;
				accent-color: var(--primary-orange);
				cursor: pointer;
				flex-shrink: 0;
				appearance: none;
				-webkit-appearance: none;
				-moz-appearance: none;
				border: 2px solid #ddd;
				border-radius: 3px;
				background: white;
				position: relative;
			}

			.category-item input[type='checkbox']:checked {
				background: var(--primary-orange);
				border-color: var(--primary-orange);
			}

			.category-item input[type='checkbox']:checked::after {
				content: '✓';
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				color: white;
				font-size: 12px;
				font-weight: bold;
			}

			.category-item .category-name {
				font-weight: 500;
				font-size: 14px;
				color: #333;
				flex: 1;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				max-width: 180px;
			}

			.category-item.selected .category-name {
				color: var(--primary-orange);
			}

			/* Main Content */
			.main-content {
				flex: 1;
				padding: 40px;
				overflow-y: auto;
			}

			/* Search section */
			.search-section {
				padding: 10px;
				background-color: white;
				display: flex;
				justify-content: flex-end;
				align-items: center;
				border: 1px solid #ccc;
				border-radius: 8px;
				/* box-shadow: 0 4px 14px rgba(0, 0, 0, 0.06); */
			}

			.search-section input {
				flex: 1;
				padding: 8px 12px;
				border: 1px solid #ccc;
				outline: none;
				border-radius: 8px;
				display: none;
			}

			.date-filter select,
			.clear-all-metrics-button button {
				border: 1px solid #ccc;
				outline: none;
				border-radius: 8px;
				outline: none;
				padding: 8px 12px;
				background-color: white;
				cursor: pointer;
			}

			.select-metrics {
				padding: 12px;
				border: 1px solid #ccc;
				outline: none;
				border-radius: 8px;
				background-color: #fff;
				margin-top: 10px;
				font-size: 14px;
				/* box-shadow: 0 4px 14px rgba(0, 0, 0, 0.06); */
			}

			.select-metrics-title {
				font-weight: bold;
			}

			.list-metrics {
				display: flex;
				flex-wrap: wrap;
				gap: 10px;
				margin-top: 10px;
			}

			.metric-item {
				padding: 6px 12px;
				border: 1px solid #ccc;
				border-radius: 8px;
				background-color: #fff;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 12px;
				transition: all 0.15s ease;
			}
			.metric-item:hover {
				box-shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
				transform: translateY(-1px);
			}

			.metric-item.selected {
				background-color: var(--primary-orange);
				color: #fff;
				border-color: var(--primary-orange);
			}

			.metric-item span {
				font-size: 14px;
			}

			/* Heatmap */
			.heatmap {
				margin-top: 20px;
				display: flex;
				justify-content: flex-end;
				align-items: center;
				gap: 10px;
				font-size: 12px;
			}
			.heatmap-color {
				width: 120px;
				border-radius: 50px;
				height: 10px;
				background: linear-gradient(
					to right,
					var(--heatmap-red),
					var(--heatmap-orange),
					var(--heatmap-yellow),
					var(--heatmap-green)
				);
				border: 1px solid #eee;
			}

			/* Heatmap table */
			.heatmap-table {
				margin-top: 20px;
			}

			.heatmap-table-body {
				border: 1px solid #e0e0e0;
				border-radius: 8px;
				background-color: #fff;
				font-size: 13px;
				overflow: hidden;
				margin-top: 20px;
			}

			/* Grid layout for heatmap */
			.heatmap-grid {
				display: grid;
				border-collapse: collapse;
			}

			.heatmap-cell {
				padding: 8px;
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 32px;
				text-align: center;
			}

			.heatmap-cell.header {
				background: #f8f9fa;
				font-weight: 600;
				color: #333;
				justify-content: center;
			}

			.heatmap-cell.category {
				font-weight: 600;
				color: #333;
				justify-content: start;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				gap: 10px;
			}

			.heatmap-cell.metric {
				font-weight: 500;
				color: #444;
				justify-content: center;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}

			/* Zebra striping for entire rows */
			.heatmap-grid:nth-child(even) .heatmap-cell {
				background: #f8f9fa;
			}

			.heatmap-grid:nth-child(odd) .heatmap-cell {
				background: #ffffff;
			}

			/* Keep header background separate */
			.heatmap-grid:first-child .heatmap-cell {
				background: #eee !important;
				min-height: 40px;
			}

			.heatmap-value {
				display: inline-block;
				padding: 4px 8px;
				border-radius: 4px;
				font-weight: 600;
				font-size: 12px;
				min-width: 50px;
				text-align: center;
				width: 100%;
				text-transform: uppercase;
			}
		</style>
	</head>
	<body>
		<div class="category-insight-dashboard-wrapper">
			<!-- Sidebar -->
			<div class="sidebar">
				<div class="sidebar-header">
					<h3>Categories</h3>
					<div class="sidebar-stats">
						<span id="selectedCount">0</span> selected
					</div>
					<div class="sidebar-actions">
						<a href="category.html" class="manage-categories-link">
							Manage Categories
						</a>
					</div>
				</div>
				<div class="sidebar-content">
					<div class="category-list">
						<!-- Search box -->
						<div class="category-search">
							<input
								id="categorySearchInput"
								type="text"
								placeholder="Search categories..."
							/>
						</div>

						<!-- All/Clear controls -->
						<div class="category-controls">
							<div class="checkbox-wrapper">
								<input
									id="selectAllCategories"
									type="checkbox"
								/>
								<label for="selectAllCategories">All</label>
							</div>
							<button class="clear-btn" id="clearAllCategories">
								Clear
							</button>
						</div>

						<!-- Categories list -->
						<div id="categoryList">
							<!-- Categories will be loaded here -->
						</div>
					</div>
				</div>
			</div>

			<!-- Main Content -->
			<div class="main-content">
				<!-- Search Section -->
				<div class="search-section">
					<input
						id="categorySearch"
						type="text"
						placeholder="Search category..."
					/>
					<!-- Date filter -->
					<div class="date-filter">
						<select id="monthsFilter">
							<option value="12" selected>Last 12 months</option>
							<option value="6">Last 6 months</option>
							<option value="3">Last 3 months</option>
							<option value="1">Last 1 month</option>
						</select>
					</div>
					<!-- Clear All Metrics Button -->
					<div class="clear-all-metrics-button">
						<button>Clear All Metrics</button>
					</div>
				</div>

				<!-- Select Metrics -->
				<div class="select-metrics">
					<span class="select-metrics-title"> Select Metrics</span>
					<div class="list-metrics">
						<!-- List metrics will be rendered by JS here -->
					</div>
				</div>

				<!-- Heatmap -->
				<div class="heatmap">
					<div class="heatmap-color"></div>
					<div class="heatmap-title">Bad -> Good</div>
				</div>

				<!-- Heatmap table -->
				<div class="heatmap-table">
					<div class="heatmap-table-header">
						<h3>
							Category Insight - Heatmap by Time
							<span class="selected-metric">(0)</span>
						</h3>
					</div>
					<div class="heatmap-table-body">
						<!-- Heatmap table body will be rendered by JS here -->
					</div>
				</div>
			</div>
		</div>

		<!-- Script -->
		<script>
			// === Config ===
			const METRICS = [
				// HIGHER IS BETTER metrics
				{ code: 'sales_units', name: 'Sales (units)', unit: 'units' },
				{ code: 'revenue', name: 'Revenue ($)', unit: 'usd' },
				{ code: 'avg_ratings', name: 'Avg. Reviews', unit: 'count' },
				{ code: 'avg_rating', name: 'Avg. Rating', unit: 'count' },
				{
					code: 'new_product_ratio',
					name: 'New product ratio (%)',
					unit: 'pct',
				},
				{ code: 'profit', name: 'Profit ($)', unit: 'usd' },
				{ code: 'margin', name: 'Margin (%)', unit: 'pct' },
				{ code: 'roi', name: 'ROI (%)', unit: 'pct' },
				// Ads metrics (new)
				{ code: 'ctr', name: 'CTR (%)', unit: 'pct' },
				{ code: 'cpc', name: 'CPC ($)', unit: 'usd' },
				{ code: 'roas', name: 'ROAS', unit: 'ratio' },
				{ code: 'cr', name: 'CR (%)', unit: 'pct' },
				{ code: 'acos', name: 'ACOS (%)', unit: 'pct' },
				{ code: 'tacos', name: 'TACOS (%)', unit: 'pct' },
				{ code: 'cpp', name: 'CPP ($)', unit: 'usd' },

				// LOWER IS BETTER metrics
				{
					code: 'listing_concentration',
					name: 'Market concentration (Top10) (%)',
					unit: 'pct',
				},
				{ code: 'referral_fee', name: 'Referral fee ($)', unit: 'usd' },
				{ code: 'fba_fee', name: 'FBA fee ($)', unit: 'usd' },
				{ code: 'cogs_cap', name: 'COGS ($)', unit: 'usd' },

				// NEUTRAL metrics
				{ code: 'avg_price', name: 'Avg. Price ($)', unit: 'usd' },
			];

			// Dynamic color mapping based on actual data values
			// Colors are calculated relative to min/max values across all selected categories

			const DEFAULT_SELECTED = new Set(['sales_units', 'revenue']);
			const selected = new Set([...DEFAULT_SELECTED]);
			const selectedCategories = new Set();
			let monthsLimit = 12;
			let allCategories = [];
			let allCategoryData = new Map(); // categoryId -> data

			function getQueryParam(name) {
				const url = new URL(window.location.href);
				return url.searchParams.get(name);
			}

			function bucketLabel(b) {
				if (/^\d{4}-\d{2}$/.test(b)) {
					const [y, m] = b.split('-');
					return `${m}/${y}`;
				}
				if (b === 'top10') return 'Top10';
				return b;
			}

			function formatValue(val, unit) {
				if (val == null || isNaN(val)) return '';
				if (unit === 'usd') {
					return `$${Number(val).toFixed(2)}`;
				}
				if (unit === 'units' || unit === 'count') {
					return `${Number(val).toFixed(0)}`;
				}
				if (unit === 'pct') {
					const pct = val < 1 ? val * 100 : val;
					const digits = 2;
					return `${Number(pct).toFixed(digits)}%`;
				}
				if (unit === 'ratio') {
					return `${Number(val).toFixed(2)}x`;
				}
				return String(val);
			}

			// Avoid rounding for FBA and Referral fees; do not use k/m compaction
			function truncateDecimals(value, digits) {
				if (typeof value !== 'number' || isNaN(value)) return value;
				const factor = Math.pow(10, digits);
				return Math.trunc(value * factor) / factor;
			}

			// Helpers for compact formatting (Sales, Revenue)
			function formatCompactUnits(val) {
				const n = Number(val);
				if (!isFinite(n)) return '';
				if (Math.abs(n) >= 1000000)
					return `${(n / 1000000).toFixed(2)}M`;
				if (Math.abs(n) >= 1000) return `${(n / 1000).toFixed(1)}k`;
				return `${n.toFixed(0)}`;
			}

			function formatCompactUSD(val) {
				const n = Number(val);
				if (!isFinite(n)) return '';
				if (Math.abs(n) >= 1000000)
					return `$${(n / 1000000).toFixed(2)}M`;
				if (Math.abs(n) >= 1000) return `$${(n / 1000).toFixed(2)}k`;
				return `$${n.toFixed(2)}`;
			}

			function formatMetricValue(metricCode, val, unit) {
				if (val == null || isNaN(val)) return '';
				// Do NOT round or compact for Avg. Reviews and Avg. Rating
				if (
					(metricCode === 'avg_ratings' ||
						metricCode === 'avg_rating') &&
					unit === 'count'
				) {
					return String(val);
				}
				// Special compact rules
				if (metricCode === 'sales_units') {
					return formatCompactUnits(Number(val));
				}
				if (metricCode === 'revenue') {
					return formatCompactUSD(Number(val));
				}
				if (metricCode === 'fba_fee' || metricCode === 'referral_fee') {
					const v = truncateDecimals(Number(val), 2);
					return `$${v}`;
				}
				return formatValue(val, unit);
			}

			// Dynamic color mapping based on actual data values

			function mapMetricColor(metricCode, value, columnValues) {
				// If no value or no data, return gray
				if (value == null || isNaN(value)) {
					return { bg: '#f5f5f5', fg: 'var(--heatmap-text)' };
				}

				// Define metric types
				const HIGHER_IS_BETTER = [
					'sales_units',
					'revenue',
					'avg_ratings',
					'avg_rating',
					'new_product_ratio',
					'margin',
					'profit',
					'net_margin',
					'ctr',
					'cr',
					'roi',
					'roas',
					'potential_score',
				];

				const LOWER_IS_BETTER = [
					'listing_concentration',
					'referral_fee',
					'fba_fee',
					'cogs_cap',
					'acos',
					'tacos',
					'return_rate',
					'cpc',
					'cpp',
				];

				const NEUTRAL = ['avg_price', 'fulfillment_ratio'];

				// For neutral metrics, always return gray
				if (NEUTRAL.includes(metricCode)) {
					return { bg: '#e8e8e8', fg: 'var(--heatmap-text)' };
				}

				// Get min and max values from this specific column (month)
				const validValues = columnValues.filter(
					(v) => typeof v === 'number' && !isNaN(v)
				);
				if (validValues.length === 0) {
					return { bg: '#f5f5f5', fg: 'var(--heatmap-text)' };
				}

				const minValue = Math.min(...validValues);
				const maxValue = Math.max(...validValues);

				// If all values are the same, return neutral color
				if (minValue === maxValue) {
					return { bg: '#e8e8e8', fg: 'var(--heatmap-text)' };
				}

				// Calculate percentile ranges for this column
				const range = maxValue - minValue;
				const p25 = minValue + range * 0.25;
				const p50 = minValue + range * 0.5;
				const p75 = minValue + range * 0.75;

				// Determine color based on metric type and value position within this column
				let bg, fg;

				if (HIGHER_IS_BETTER.includes(metricCode)) {
					// Higher is better: Green = high, Red = low
					if (value <= p25) {
						// Bottom 25% - Red (worst)
						bg = 'var(--heatmap-red)';
						fg = 'var(--heatmap-text)';
					} else if (value <= p50) {
						// 25-50% - Orange
						bg = 'var(--heatmap-orange)';
						fg = 'var(--heatmap-text)';
					} else if (value <= p75) {
						// 50-75% - Yellow
						bg = 'var(--heatmap-yellow)';
						fg = 'var(--heatmap-text)';
					} else {
						// Top 25% - Green (best)
						bg = 'var(--heatmap-green)';
						fg = 'var(--heatmap-text)';
					}
				} else if (LOWER_IS_BETTER.includes(metricCode)) {
					// Lower is better: Green = low, Red = high
					if (value <= p25) {
						// Bottom 25% - Green (best)
						bg = 'var(--heatmap-green)';
						fg = 'var(--heatmap-text)';
					} else if (value <= p50) {
						// 25-50% - Yellow
						bg = 'var(--heatmap-yellow)';
						fg = 'var(--heatmap-text)';
					} else if (value <= p75) {
						// 50-75% - Orange
						bg = 'var(--heatmap-orange)';
						fg = 'var(--heatmap-text)';
					} else {
						// Top 25% - Red (worst)
						bg = 'var(--heatmap-red)';
						fg = 'var(--heatmap-text)';
					}
				} else {
					// Default to neutral gray for unknown metrics
					return { bg: '#e8e8e8', fg: 'var(--heatmap-text)' };
				}

				return { bg, fg };
			}

			function renderMetricChips() {
				const list = document.querySelector('.list-metrics');
				list.innerHTML = '';
				METRICS.forEach((m) => {
					const div = document.createElement('div');
					div.className =
						'metric-item' +
						(selected.has(m.code) ? ' selected' : '');
					div.textContent = m.name;
					div.onclick = () => {
						if (selected.has(m.code)) selected.delete(m.code);
						else selected.add(m.code);
						// visually toggle selected state
						div.classList.toggle('selected', selected.has(m.code));
						document.querySelector(
							'.selected-metric'
						).textContent = `(${selected.size})`;
						renderHeatmap();
					};
					list.appendChild(div);
				});
				document.querySelector(
					'.selected-metric'
				).textContent = `(${selected.size})`;
				// Attach clear button
				const clearBtn = document.querySelector(
					'.clear-all-metrics-button button'
				);
				if (clearBtn && !clearBtn.__bound) {
					clearBtn.onclick = () => {
						selected.clear();
						// update chip visuals
						document
							.querySelectorAll('.list-metrics .metric-item')
							.forEach((el) => el.classList.remove('selected'));
						document.querySelector('.selected-metric').textContent =
							'(0)';
						renderHeatmap();
					};
					clearBtn.__bound = true;
				}
			}

			function buildValueMap(timeSeries) {
				const map = {};
				(timeSeries || []).forEach((p) => {
					map[p.bucket] = p.value;
				});
				return map;
			}

			function renderHeatmap() {
				const container = document.querySelector('.heatmap-table-body');
				console.log(
					'Rendering heatmap, selectedCategories:',
					Array.from(selectedCategories)
				);
				console.log(
					'allCategoryData keys:',
					Array.from(allCategoryData.keys())
				);

				if (selectedCategories.size === 0) {
					container.innerHTML =
						'<p style="color:#999;text-align:center;padding:40px">Select categories from the sidebar to view heatmap</p>';
					return;
				}

				// Collect all time buckets from selected categories
				const allTimeBuckets = new Set();
				selectedCategories.forEach((categoryId) => {
					const data = allCategoryData.get(categoryId);
					if (data && data.timeBuckets) {
						data.timeBuckets.forEach((bucket) =>
							allTimeBuckets.add(bucket)
						);
					}
				});

				// Listing concentration is monthly; do not add a separate Top10 column

				// Filter out 'overall' bucket and sort
				const rawBuckets = Array.from(allTimeBuckets).filter(
					(b) => b !== 'overall'
				);
				const known = rawBuckets
					.filter((b) => /^\d{4}-\d{2}$/.test(b))
					.sort((a, b) => {
						const aKey = parseInt(a.replace('-', ''), 10);
						const bKey = parseInt(b.replace('-', ''), 10);
						return bKey - aKey; // desc
					});
				const unknown = rawBuckets.filter(
					(b) => !/^\d{4}-\d{2}$/.test(b)
				);
				let buckets = known.concat(unknown);

				// Apply months limit only on known year-month buckets
				if (monthsLimit && monthsLimit > 0) {
					const limitedKnown = known.slice(0, monthsLimit);
					buckets = limitedKnown.concat(unknown);
				}

				// No extra Top10 column

				const gridCols = `200px 300px repeat(${buckets.length}, 1fr)`;
				const header = [
					`<div class="heatmap-grid" style="grid-template-columns:${gridCols};position:sticky;top:0;z-index:2;">`,
					'<div class="heatmap-cell header">Category</div>',
					'<div class="heatmap-cell header">Metric</div>',
					buckets
						.map(
							(b) =>
								`<div class="heatmap-cell header">${bucketLabel(
									b
								)}</div>`
						)
						.join(''),
					'</div>',
				].join('');

				// Prepare rows for all selected categories
				const metricRows = [];
				const selectedDefs = METRICS.filter((def) =>
					selected.has(def.code)
				);

				// Helper: get value for specific metric and bucket with fallbacks
				function getMetricValueForBucket(data, metricCode, bucket) {
					if (!data) return null;
					const ts = (data.timeSeriesData || []).find(
						(m) => m.metric === metricCode
					);
					if (ts && Array.isArray(ts.timeSeries)) {
						const hit = ts.timeSeries.find(
							(p) => p.bucket === bucket
						);
						if (hit && typeof hit.value === 'number')
							return hit.value;
					}
					// Category-level constant for FBA
					if (
						metricCode === 'fba_fee' &&
						data?.category?.fbaFeeUsd != null
					) {
						const v = Number(data.category.fbaFeeUsd);
						if (!Number.isNaN(v)) return v;
					}
					// Fallback to metricsSummary ONLY when month matches exactly
					if (Array.isArray(data?.metricsSummary)) {
						const ms = data.metricsSummary.find(
							(x) => x.metric === metricCode
						);
						if (
							ms &&
							typeof ms.latestValue === 'number' &&
							ms.latestBucket === bucket
						) {
							return ms.latestValue;
						}
					}
					return null;
				}

				// Group values by category and metric (row) for per-row color calculation
				const valuesByCategoryAndMetric = {};
				selectedCategories.forEach((categoryId) => {
					valuesByCategoryAndMetric[categoryId] = {};
					selectedDefs.forEach((def) => {
						valuesByCategoryAndMetric[categoryId][def.code] = [];

						const data = allCategoryData.get(categoryId);
						if (data && data.timeSeriesData) {
							const metricData = data.timeSeriesData.find(
								(m) => m.metric === def.code
							);
							if (metricData && metricData.timeSeries) {
								metricData.timeSeries.forEach((ts) => {
									if (
										typeof ts.value === 'number' &&
										buckets.includes(ts.bucket)
									) {
										valuesByCategoryAndMetric[categoryId][
											def.code
										].push(ts.value);
									}
								});
							}

							// Fallbacks when no series
							if (
								valuesByCategoryAndMetric[categoryId][def.code]
									.length === 0
							) {
								let constantVal = null;
								let fillAllBuckets = false;
								// A) Category-level constant for FBA
								if (def.code === 'fba_fee') {
									const c = Number(data?.category?.fbaFeeUsd);
									if (!Number.isNaN(c)) {
										constantVal = c;
										fillAllBuckets = true;
									}
								}
								// B) Latest from metricsSummary (only if bucket matches)
								if (
									constantVal == null &&
									Array.isArray(data?.metricsSummary)
								) {
									const ms = data.metricsSummary.find(
										(x) => x.metric === def.code
									);
									if (
										ms &&
										typeof ms.latestValue === 'number' &&
										ms.latestBucket &&
										buckets.includes(ms.latestBucket)
									) {
										// do not spread across months; only use exact bucket later per-cell
										constantVal = null;
									}
								}
								// C) Try datasets[].metrics overall bucket (legacy)
								if (
									constantVal == null &&
									Array.isArray(data?.datasets)
								) {
									for (const ds of data.datasets) {
										const arr = ds.metrics?.[def.code];
										if (Array.isArray(arr)) {
											const ov = arr.find(
												(m) => m.bucket === 'overall'
											);
											if (
												ov &&
												typeof ov.value === 'number'
											) {
												constantVal = ov.value;
												fillAllBuckets = true;
												break;
											}
										}
									}
								}
								if (
									constantVal != null &&
									!Number.isNaN(constantVal)
								) {
									if (fillAllBuckets) {
										buckets.forEach(() => {
											valuesByCategoryAndMetric[
												categoryId
											][def.code].push(constantVal);
										});
									} else {
										// Push once to enable color mapping at least
										valuesByCategoryAndMetric[categoryId][
											def.code
										].push(constantVal);
									}
								}
							}
						}
					});
				});

				// Additionally, synthesize row values for derived metrics using available inputs per bucket
				selectedCategories.forEach((categoryId) => {
					const data = allCategoryData.get(categoryId);
					if (!data) return;
					const rowStore =
						valuesByCategoryAndMetric[categoryId] || {};
					buckets.forEach((b) => {
						const price = getMetricValueForBucket(
							data,
							'avg_price',
							b
						);
						const referral =
							getMetricValueForBucket(data, 'referral_fee', b) ||
							0;
						const fba =
							getMetricValueForBucket(data, 'fba_fee', b) || 0;
						if (typeof price === 'number') {
							const ads = 0.2 * price;
							const cogsAssumed = 0.2 * price;
							const profitDollar =
								price - (ads + referral + fba + cogsAssumed);
							const marginPct =
								price > 0 ? (profitDollar / price) * 100 : null;
							const roiPct =
								cogsAssumed > 0
									? (profitDollar / cogsAssumed) * 100
									: null;

							(rowStore['profit'] ||= []).push(profitDollar);
							(rowStore['margin'] ||= []).push(marginPct);
							(rowStore['roi'] ||= []).push(roiPct);
						}
					});
					valuesByCategoryAndMetric[categoryId] = rowStore;
				});

				// Sort categories based on selected metrics
				const sortedCategoryIds = Array.from(selectedCategories).sort(
					(a, b) => {
						const dataA = allCategoryData.get(a);
						const dataB = allCategoryData.get(b);

						if (!dataA || !dataB) return 0;

						// Get the primary metric to sort by
						const primaryMetric = selectedDefs[0]; // First selected metric
						if (!primaryMetric) return 0;

						// Get latest value for primary metric
						const getLatestValue = (data, metricCode) => {
							const byMetric = {};
							(data.timeSeriesData || []).forEach(
								(m) => (byMetric[m.metric] = m)
							);

							const metricData = byMetric[metricCode];
							if (!metricData || !metricData.timeSeries)
								return null;

							// Find latest month value
							const latestMonth = metricData.timeSeries
								.filter((ts) => /^\d{4}-\d{2}$/.test(ts.bucket))
								.sort((a, b) =>
									b.bucket.localeCompare(a.bucket)
								)[0];

							return latestMonth ? latestMonth.value : null;
						};

						const valueA = getLatestValue(
							dataA,
							primaryMetric.code
						);
						const valueB = getLatestValue(
							dataB,
							primaryMetric.code
						);

						// Handle null values
						if (valueA == null && valueB == null) return 0;
						if (valueA == null) return 1; // null values go to bottom
						if (valueB == null) return -1;

						// Sort descending (high to low)
						return valueB - valueA;
					}
				);

				sortedCategoryIds.forEach((categoryId) => {
					const data = allCategoryData.get(categoryId);
					if (!data) return;

					const byMetric = {};
					(data.timeSeriesData || []).forEach(
						(m) => (byMetric[m.metric] = m)
					);

					const availableCount = selectedDefs.filter(
						(def) => (byMetric[def.code]?.timeSeries || []).length
					).length;

					// Create category group with proper styling
					const categoryGroupRows = [];

					selectedDefs.forEach((def, index) => {
						const series = byMetric[def.code]?.timeSeries || [];
						const valuesByBucket = buildValueMap(series);

						const cells = buckets
							.map((b) => {
								let v = valuesByBucket[b];
								// Compute derived metrics when missing
								if (
									v == null &&
									(def.code === 'profit' ||
										def.code === 'margin' ||
										def.code === 'roi')
								) {
									const price = getMetricValueForBucket(
										data,
										'avg_price',
										b
									);
									const referral =
										getMetricValueForBucket(
											data,
											'referral_fee',
											b
										) || 0;
									const fba =
										getMetricValueForBucket(
											data,
											'fba_fee',
											b
										) || 0;
									if (typeof price === 'number') {
										const ads = 0.2 * price;
										const cogsAssumed = 0.2 * price;
										const profitDollar =
											price -
											(ads +
												referral +
												fba +
												cogsAssumed);
										if (def.code === 'profit')
											v = profitDollar;
										else if (def.code === 'margin')
											v =
												price > 0
													? (profitDollar / price) *
													  100
													: null;
										else if (def.code === 'roi')
											v =
												cogsAssumed > 0
													? (profitDollar /
															cogsAssumed) *
													  100
													: null;
									}
								}
								// Per-cell fallback using metricsSummary and constants
								if (v == null) {
									// Listing concentration: if only summary exists, show across months
									if (def.code === 'listing_concentration') {
										const ms = Array.isArray(
											data?.metricsSummary
										)
											? data.metricsSummary.find(
													(x) =>
														x.metric ===
														'listing_concentration'
											  )
											: null;
										if (
											ms &&
											typeof ms.latestValue ===
												'number' &&
											(ms.latestBucket === 'top10' ||
												ms.latestBucket === 'overall' ||
												!ms.latestBucket)
										) {
											v = ms.latestValue;
										}
									}
									// Category-level FBA fee
									if (
										def.code === 'fba_fee' &&
										data?.category?.fbaFeeUsd != null
									) {
										v = Number(data.category.fbaFeeUsd);
									} else if (
										Array.isArray(data?.metricsSummary)
									) {
										const ms = data.metricsSummary.find(
											(x) => x.metric === def.code
										);
										if (
											ms &&
											typeof ms.latestValue === 'number'
										) {
											// For referral_fee, show latestValue across months
											if (def.code === 'referral_fee') {
												v = ms.latestValue;
											} else if (
												ms.latestBucket === 'overall' ||
												!ms.latestBucket
											) {
												v = ms.latestValue;
											} else if (ms.latestBucket === b) {
												v = ms.latestValue;
											}
										}
									}
								}
								// Get values for this specific category and metric (row)
								const rowValues =
									valuesByCategoryAndMetric[categoryId][
										def.code
									] || [];
								const { bg, fg } = mapMetricColor(
									def.code,
									v,
									rowValues
								);
								const label = formatMetricValue(
									def.code,
									v,
									def.unit
								);
								return `<div class="heatmap-cell"><span class="heatmap-value" style="background:${bg};color:${fg};border: 1px solid ${bg}">${
									label || '-'
								}</span></div>`;
							})
							.join('');

						// Category name only on first metric row
						const firstCol =
							index === 0
								? `<div class="heatmap-cell category">${
										data.category?.name || ''
								  }<div style="color:#999;font-size:11px;font-weight:400;margin-top:2px">${availableCount} metric${
										availableCount === 1 ? '' : 's'
								  }</div></div>`
								: '<div class="heatmap-cell"></div>';

						categoryGroupRows.push(
							`<div class="heatmap-grid" style="grid-template-columns:${gridCols};">` +
								firstCol +
								`<div class="heatmap-cell metric">${def.name}</div>` +
								cells +
								'</div>'
						);
					});

					metricRows.push(...categoryGroupRows);
				});

				container.innerHTML = header + metricRows.join('');
			}

			async function loadCategories() {
				try {
					const r = await fetch('/api/research/categories');
					if (!r.ok) throw new Error('Failed to load categories');
					allCategories = await r.json();
					renderCategoryList();

					// Auto-select category from URL parameter after categories are loaded
					const categoryId = getQueryParam('id');
					if (categoryId) {
						// Check if the category exists in the loaded list
						const categoryExists = allCategories.some(
							(cat) => cat._id === categoryId
						);
						if (categoryExists) {
							await toggleCategory(categoryId);
							console.log(
								'Auto-selected category from URL:',
								categoryId
							);
						} else {
							console.warn('Category not found:', categoryId);
						}
					}
				} catch (e) {
					console.error('Failed to load categories:', e);
					document.getElementById('categoryList').innerHTML =
						'<p style="color:#e53935;padding:20px;text-align:center">Failed to load categories</p>';
				}
			}

			function renderCategoryList(filterText = '') {
				const container = document.getElementById('categoryList');
				container.innerHTML = '';

				const q = String(filterText || '')
					.toLowerCase()
					.trim();
				const list = q
					? allCategories.filter((c) =>
							String(c.name || '')
								.toLowerCase()
								.includes(q)
					  )
					: allCategories;

				list.forEach((category) => {
					const div = document.createElement('div');
					div.className = 'category-item';
					div.dataset.categoryId = category._id;

					const isSelected = selectedCategories.has(category._id);
					if (isSelected) {
						div.classList.add('selected');
					}

					div.innerHTML = `
						<input
							type="checkbox"
							${isSelected ? 'checked' : ''}
							onchange="toggleCategory('${category._id}')"
						/>
						<div class="category-name" title="${category.name}">${category.name}</div>
					`;

					// Also handle click on the entire item
					div.onclick = (e) => {
						if (e.target.type !== 'checkbox') {
							toggleCategory(category._id);
						}
					};

					container.appendChild(div);
				});

				// Update select all checkbox state
				updateSelectAllState();
			}

			async function selectOnlyCategory(categoryId) {
				try {
					// Clear current selection
					selectedCategories.clear();
					allCategoryData.clear();
					updateCategorySelection();
					updateSelectedCount();

					// Add and load the requested category
					selectedCategories.add(categoryId);
					if (!allCategoryData.has(categoryId)) {
						const r = await fetch(
							`/api/research/category/${categoryId}`
						);
						if (r.ok) {
							const data = await r.json();
							allCategoryData.set(categoryId, data);
						}
					}
					updateCategorySelection();
					updateSelectedCount();
					updateSelectAllState();
					renderHeatmap();
				} catch (e) {
					console.error('Failed to select only category:', e);
				}
			}

			async function toggleCategory(categoryId) {
				console.log('Toggling category:', categoryId);
				if (selectedCategories.has(categoryId)) {
					selectedCategories.delete(categoryId);
					allCategoryData.delete(categoryId);
					console.log('Removed category:', categoryId);
				} else {
					selectedCategories.add(categoryId);
					console.log('Added category:', categoryId);
					// Load category data if not already loaded
					if (!allCategoryData.has(categoryId)) {
						try {
							console.log(
								'Loading data for category:',
								categoryId
							);
							const r = await fetch(
								`/api/research/category/${categoryId}`
							);
							if (r.ok) {
								const data = await r.json();
								console.log('Loaded category data:', data);
								allCategoryData.set(categoryId, data);
							} else {
								console.error(
									'Failed to load category data, status:',
									r.status
								);
							}
						} catch (e) {
							console.error('Failed to load category data:', e);
						}
					} else {
						console.log(
							'Category data already loaded:',
							categoryId
						);
					}
				}

				// Update UI
				updateCategorySelection();
				updateSelectedCount();
				updateSelectAllState();
				renderHeatmap();
			}

			function updateCategorySelection() {
				document.querySelectorAll('.category-item').forEach((item) => {
					const categoryId = item.dataset.categoryId;
					const checkbox = item.querySelector(
						'input[type="checkbox"]'
					);

					if (selectedCategories.has(categoryId)) {
						item.classList.add('selected');
						if (checkbox) checkbox.checked = true;
					} else {
						item.classList.remove('selected');
						if (checkbox) checkbox.checked = false;
					}
				});
			}

			function updateSelectedCount() {
				document.getElementById('selectedCount').textContent =
					selectedCategories.size;
			}

			function updateSelectAllState() {
				const selectAllCheckbox = document.getElementById(
					'selectAllCategories'
				);
				if (!selectAllCheckbox) return;

				const visibleCategories = Array.from(
					document.querySelectorAll('.category-item')
				).map((item) => item.dataset.categoryId);

				const selectedVisible = visibleCategories.filter((id) =>
					selectedCategories.has(id)
				);

				if (selectedVisible.length === 0) {
					selectAllCheckbox.checked = false;
					selectAllCheckbox.indeterminate = false;
				} else if (
					selectedVisible.length === visibleCategories.length
				) {
					selectAllCheckbox.checked = true;
					selectAllCheckbox.indeterminate = false;
				} else {
					selectAllCheckbox.checked = false;
					selectAllCheckbox.indeterminate = true;
				}
			}

			async function selectAllCategories() {
				const visibleCategories = Array.from(
					document.querySelectorAll('.category-item')
				).map((item) => item.dataset.categoryId);

				for (const categoryId of visibleCategories) {
					if (!selectedCategories.has(categoryId)) {
						selectedCategories.add(categoryId);
						// Load category data if not already loaded
						if (!allCategoryData.has(categoryId)) {
							try {
								const r = await fetch(
									`/api/research/category/${categoryId}`
								);
								if (r.ok) {
									const data = await r.json();
									allCategoryData.set(categoryId, data);
								}
							} catch (e) {
								console.error(
									'Failed to load category data:',
									e
								);
							}
						}
					}
				}

				updateCategorySelection();
				updateSelectedCount();
				updateSelectAllState();
				renderHeatmap();
			}

			function clearAllCategories() {
				selectedCategories.clear();
				allCategoryData.clear();
				updateCategorySelection();
				updateSelectedCount();
				updateSelectAllState();
				renderHeatmap();
			}

			async function loadCategory() {
				// Legacy function - now just load all categories
				await loadCategories();
			}

			// Init
			renderMetricChips();
			loadCategory();

			// Search wiring
			const searchInput = document.getElementById('categorySearchInput');
			if (searchInput) {
				if (!searchInput.__bound) {
					searchInput.addEventListener('input', (e) => {
						renderCategoryList(e.target.value || '');
					});
					searchInput.addEventListener('keydown', async (e) => {
						if (e.key === 'Enter') {
							const q = String(searchInput.value || '')
								.toLowerCase()
								.trim();
							if (!q) return;
							const match = allCategories.find((c) =>
								String(c.name || '')
									.toLowerCase()
									.includes(q)
							);
							if (match) {
								await selectOnlyCategory(match._id);
								// keep filtered list focused on the selected one
								renderCategoryList(q);
							}
						}
					});
					searchInput.__bound = true;
				}
			}

			// Select All checkbox wiring
			const selectAllCheckbox = document.getElementById(
				'selectAllCategories'
			);
			if (selectAllCheckbox) {
				selectAllCheckbox.addEventListener('change', async (e) => {
					if (e.target.checked) {
						await selectAllCategories();
					} else {
						clearAllCategories();
					}
				});
			}

			// Clear All button wiring
			const clearAllBtn = document.getElementById('clearAllCategories');
			if (clearAllBtn) {
				clearAllBtn.addEventListener('click', () => {
					clearAllCategories();
				});
			}

			const monthsSelect = document.getElementById('monthsFilter');
			if (monthsSelect) {
				monthsSelect.addEventListener('change', () => {
					monthsLimit =
						parseInt(monthsSelect.value || '12', 10) || 12;
					renderHeatmap();
				});
			}
		</script>
	</body>
</html>
